{"version":3,"names":[],"mappings":"","sources":["polymer/polymer-mini.html"],"sourcesContent":["<!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><link rel=\"import\" href=\"polymer-micro.html\">\n\n<script>Polymer.Base._addFeature({\n_prepTemplate: function () {\nthis._template = this._template || Polymer.DomModule.import(this.is, 'template');\nif (this._template && this._template.hasAttribute('is')) {\nthis._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));\n}\nif (this._template && !this._template.content && HTMLTemplateElement.bootstrap) {\nHTMLTemplateElement.decorate(this._template);\nHTMLTemplateElement.bootstrap(this._template.content);\n}\n},\n_stampTemplate: function () {\nif (this._template) {\nthis.root = this.instanceTemplate(this._template);\n}\n},\ninstanceTemplate: function (template) {\nvar dom = document.importNode(template._content || template.content, true);\nreturn dom;\n}\n});\n(function () {\nvar baseAttachedCallback = Polymer.Base.attachedCallback;\nPolymer.Base._addFeature({\n_hostStack: [],\nready: function () {\n},\n_pushHost: function (host) {\nthis.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];\nif (host && host._clients) {\nhost._clients.push(this);\n}\nthis._beginHost();\n},\n_beginHost: function () {\nPolymer.Base._hostStack.push(this);\nif (!this._clients) {\nthis._clients = [];\n}\n},\n_popHost: function () {\nPolymer.Base._hostStack.pop();\n},\n_tryReady: function () {\nif (this._canReady()) {\nthis._ready();\n}\n},\n_canReady: function () {\nreturn !this.dataHost || this.dataHost._clientsReadied;\n},\n_ready: function () {\nthis._beforeClientsReady();\nthis._setupRoot();\nthis._readyClients();\nthis._afterClientsReady();\nthis._readySelf();\n},\n_readyClients: function () {\nthis._beginDistribute();\nvar c$ = this._clients;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._ready();\n}\nthis._finishDistribute();\nthis._clientsReadied = true;\nthis._clients = null;\n},\n_readySelf: function () {\nthis._doBehavior('ready');\nthis._readied = true;\nif (this._attachedPending) {\nthis._attachedPending = false;\nthis.attachedCallback();\n}\n},\n_beforeClientsReady: function () {\n},\n_afterClientsReady: function () {\n},\n_beforeAttached: function () {\n},\nattachedCallback: function () {\nif (this._readied) {\nthis._beforeAttached();\nbaseAttachedCallback.call(this);\n} else {\nthis._attachedPending = true;\n}\n}\n});\n}());\nPolymer.ArraySplice = function () {\nfunction newSplice(index, removed, addedCount) {\nreturn {\nindex: index,\nremoved: removed,\naddedCount: addedCount\n};\n}\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3;\nfunction ArraySplice() {\n}\nArraySplice.prototype = {\ncalcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar rowCount = oldEnd - oldStart + 1;\nvar columnCount = currentEnd - currentStart + 1;\nvar distances = new Array(rowCount);\nfor (var i = 0; i < rowCount; i++) {\ndistances[i] = new Array(columnCount);\ndistances[i][0] = i;\n}\nfor (var j = 0; j < columnCount; j++)\ndistances[0][j] = j;\nfor (var i = 1; i < rowCount; i++) {\nfor (var j = 1; j < columnCount; j++) {\nif (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\ndistances[i][j] = distances[i - 1][j - 1];\nelse {\nvar north = distances[i - 1][j] + 1;\nvar west = distances[i][j - 1] + 1;\ndistances[i][j] = north < west ? north : west;\n}\n}\n}\nreturn distances;\n},\nspliceOperationsFromEditDistances: function (distances) {\nvar i = distances.length - 1;\nvar j = distances[0].length - 1;\nvar current = distances[i][j];\nvar edits = [];\nwhile (i > 0 || j > 0) {\nif (i == 0) {\nedits.push(EDIT_ADD);\nj--;\ncontinue;\n}\nif (j == 0) {\nedits.push(EDIT_DELETE);\ni--;\ncontinue;\n}\nvar northWest = distances[i - 1][j - 1];\nvar west = distances[i - 1][j];\nvar north = distances[i][j - 1];\nvar min;\nif (west < north)\nmin = west < northWest ? west : northWest;\nelse\nmin = north < northWest ? north : northWest;\nif (min == northWest) {\nif (northWest == current) {\nedits.push(EDIT_LEAVE);\n} else {\nedits.push(EDIT_UPDATE);\ncurrent = northWest;\n}\ni--;\nj--;\n} else if (min == west) {\nedits.push(EDIT_DELETE);\ni--;\ncurrent = west;\n} else {\nedits.push(EDIT_ADD);\nj--;\ncurrent = north;\n}\n}\nedits.reverse();\nreturn edits;\n},\ncalcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar prefixCount = 0;\nvar suffixCount = 0;\nvar minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\nif (currentStart == 0 && oldStart == 0)\nprefixCount = this.sharedPrefix(current, old, minLength);\nif (currentEnd == current.length && oldEnd == old.length)\nsuffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\ncurrentStart += prefixCount;\noldStart += prefixCount;\ncurrentEnd -= suffixCount;\noldEnd -= suffixCount;\nif (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\nreturn [];\nif (currentStart == currentEnd) {\nvar splice = newSplice(currentStart, [], 0);\nwhile (oldStart < oldEnd)\nsplice.removed.push(old[oldStart++]);\nreturn [splice];\n} else if (oldStart == oldEnd)\nreturn [newSplice(currentStart, [], currentEnd - currentStart)];\nvar ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\nvar splice = undefined;\nvar splices = [];\nvar index = currentStart;\nvar oldIndex = oldStart;\nfor (var i = 0; i < ops.length; i++) {\nswitch (ops[i]) {\ncase EDIT_LEAVE:\nif (splice) {\nsplices.push(splice);\nsplice = undefined;\n}\nindex++;\noldIndex++;\nbreak;\ncase EDIT_UPDATE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\ncase EDIT_ADD:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nbreak;\ncase EDIT_DELETE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\n}\n}\nif (splice) {\nsplices.push(splice);\n}\nreturn splices;\n},\nsharedPrefix: function (current, old, searchLength) {\nfor (var i = 0; i < searchLength; i++)\nif (!this.equals(current[i], old[i]))\nreturn i;\nreturn searchLength;\n},\nsharedSuffix: function (current, old, searchLength) {\nvar index1 = current.length;\nvar index2 = old.length;\nvar count = 0;\nwhile (count < searchLength && this.equals(current[--index1], old[--index2]))\ncount++;\nreturn count;\n},\ncalculateSplices: function (current, previous) {\nreturn this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n},\nequals: function (currentValue, previousValue) {\nreturn currentValue === previousValue;\n}\n};\nreturn new ArraySplice();\n}();\nPolymer.domInnerHTML = function () {\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\nfunction escapeReplace(c) {\nswitch (c) {\ncase '&':\nreturn '&amp;';\ncase '<':\nreturn '&lt;';\ncase '>':\nreturn '&gt;';\ncase '\"':\nreturn '&quot;';\ncase '\\xA0':\nreturn '&nbsp;';\n}\n}\nfunction escapeAttr(s) {\nreturn s.replace(escapeAttrRegExp, escapeReplace);\n}\nfunction escapeData(s) {\nreturn s.replace(escapeDataRegExp, escapeReplace);\n}\nfunction makeSet(arr) {\nvar set = {};\nfor (var i = 0; i < arr.length; i++) {\nset[arr[i]] = true;\n}\nreturn set;\n}\nvar voidElements = makeSet([\n'area',\n'base',\n'br',\n'col',\n'command',\n'embed',\n'hr',\n'img',\n'input',\n'keygen',\n'link',\n'meta',\n'param',\n'source',\n'track',\n'wbr'\n]);\nvar plaintextParents = makeSet([\n'style',\n'script',\n'xmp',\n'iframe',\n'noembed',\n'noframes',\n'plaintext',\n'noscript'\n]);\nfunction getOuterHTML(node, parentNode, composed) {\nswitch (node.nodeType) {\ncase Node.ELEMENT_NODE:\nvar tagName = node.localName;\nvar s = '<' + tagName;\nvar attrs = node.attributes;\nfor (var i = 0, attr; attr = attrs[i]; i++) {\ns += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n}\ns += '>';\nif (voidElements[tagName]) {\nreturn s;\n}\nreturn s + getInnerHTML(node, composed) + '</' + tagName + '>';\ncase Node.TEXT_NODE:\nvar data = node.data;\nif (parentNode && plaintextParents[parentNode.localName]) {\nreturn data;\n}\nreturn escapeData(data);\ncase Node.COMMENT_NODE:\nreturn '<!--' + node.data + '-->';\ndefault:\nconsole.error(node);\nthrow new Error('not implemented');\n}\n}\nfunction getInnerHTML(node, composed) {\nif (node instanceof HTMLTemplateElement)\nnode = node.content;\nvar s = '';\nvar c$ = Polymer.dom(node).childNodes;\nc$ = composed ? node._composedChildren : c$;\nfor (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\ns += getOuterHTML(child, node, composed);\n}\nreturn s;\n}\nreturn { getInnerHTML: getInnerHTML };\n}();\nPolymer.DomApi = function () {\n'use strict';\nvar Settings = Polymer.Settings;\nvar getInnerHTML = Polymer.domInnerHTML.getInnerHTML;\nvar nativeInsertBefore = Element.prototype.insertBefore;\nvar nativeRemoveChild = Element.prototype.removeChild;\nvar nativeAppendChild = Element.prototype.appendChild;\nvar nativeCloneNode = Element.prototype.cloneNode;\nvar nativeImportNode = Document.prototype.importNode;\nvar DomApi = function (node) {\nthis.node = node;\nif (this.patch) {\nthis.patch();\n}\n};\nif (window.wrap && Settings.useShadow && !Settings.useNativeShadow) {\nDomApi = function (node) {\nthis.node = wrap(node);\nif (this.patch) {\nthis.patch();\n}\n};\n}\nDomApi.prototype = {\nflush: function () {\nPolymer.dom.flush();\n},\ndeepContains: function (node) {\nif (this.node.contains(node)) {\nreturn true;\n}\nvar n = node;\nvar wrappedDocument = wrap(document);\nwhile (n && n !== wrappedDocument && n !== this.node) {\nn = Polymer.dom(n).parentNode || n.host;\n}\nreturn n === this.node;\n},\n_lazyDistribute: function (host) {\nif (host.shadyRoot && host.shadyRoot._distributionClean) {\nhost.shadyRoot._distributionClean = false;\nPolymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));\n}\n},\nappendChild: function (node) {\nreturn this._addNode(node);\n},\ninsertBefore: function (node, ref_node) {\nreturn this._addNode(node, ref_node);\n},\n_addNode: function (node, ref_node) {\nthis._removeNodeFromParent(node);\nvar addedInsertionPoint;\nvar root = this.getOwnerRoot();\nif (root) {\naddedInsertionPoint = this._maybeAddInsertionPoint(node, this.node);\n}\nif (this._nodeHasLogicalChildren(this.node)) {\nif (ref_node) {\nvar children = this.childNodes;\nvar index = children.indexOf(ref_node);\nif (index < 0) {\nthrow Error('The ref_node to be inserted before is not a child ' + 'of this node');\n}\n}\nthis._addLogicalInfo(node, this.node, index);\n}\nthis._addNodeToHost(node);\nif (!this._maybeDistribute(node, this.node) && !this._tryRemoveUndistributedNode(node)) {\nif (ref_node) {\nref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;\n}\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\naddToComposedParent(container, node, ref_node);\nif (ref_node) {\nnativeInsertBefore.call(container, node, ref_node);\n} else {\nnativeAppendChild.call(container, node);\n}\n}\nif (addedInsertionPoint) {\nthis._updateInsertionPoints(root.host);\n}\nthis.notifyObserver();\nreturn node;\n},\nremoveChild: function (node) {\nif (factory(node).parentNode !== this.node) {\nconsole.warn('The node to be removed is not a child of this node', node);\n}\nthis._removeNodeFromHost(node);\nif (!this._maybeDistribute(node, this.node)) {\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\nif (container === node.parentNode) {\nremoveFromComposedParent(container, node);\nnativeRemoveChild.call(container, node);\n}\n}\nthis.notifyObserver();\nreturn node;\n},\nreplaceChild: function (node, ref_node) {\nthis.insertBefore(node, ref_node);\nthis.removeChild(ref_node);\nreturn node;\n},\n_hasCachedOwnerRoot: function (node) {\nreturn Boolean(node._ownerShadyRoot !== undefined);\n},\ngetOwnerRoot: function () {\nreturn this._ownerShadyRootForNode(this.node);\n},\n_ownerShadyRootForNode: function (node) {\nif (!node) {\nreturn;\n}\nif (node._ownerShadyRoot === undefined) {\nvar root;\nif (node._isShadyRoot) {\nroot = node;\n} else {\nvar parent = Polymer.dom(node).parentNode;\nif (parent) {\nroot = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);\n} else {\nroot = null;\n}\n}\nnode._ownerShadyRoot = root;\n}\nreturn node._ownerShadyRoot;\n},\n_maybeDistribute: function (node, parent) {\nvar fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);\nvar wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;\nvar hasContent = fragContent || node.localName === CONTENT;\nif (hasContent) {\nvar root = this._ownerShadyRootForNode(parent);\nif (root) {\nvar host = root.host;\nthis._lazyDistribute(host);\n}\n}\nvar parentNeedsDist = this._parentNeedsDistribution(parent);\nif (parentNeedsDist) {\nthis._lazyDistribute(parent);\n}\nreturn parentNeedsDist || hasContent && !wrappedContent;\n},\n_maybeAddInsertionPoint: function (node, parent) {\nvar added;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {\nvar c$ = factory(node).querySelectorAll(CONTENT);\nfor (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {\nnp = factory(n).parentNode;\nif (np === node) {\nnp = parent;\n}\nna = this._maybeAddInsertionPoint(n, np);\nadded = added || na;\n}\n} else if (node.localName === CONTENT) {\nsaveLightChildrenIfNeeded(parent);\nsaveLightChildrenIfNeeded(node);\nadded = true;\n}\nreturn added;\n},\n_tryRemoveUndistributedNode: function (node) {\nif (this.node.shadyRoot) {\nvar parent = getComposedParent(node);\nif (parent) {\nnativeRemoveChild.call(parent, node);\n}\nreturn true;\n}\n},\n_updateInsertionPoints: function (host) {\nvar i$ = host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nsaveLightChildrenIfNeeded(c);\nsaveLightChildrenIfNeeded(factory(c).parentNode);\n}\n},\n_nodeHasLogicalChildren: function (node) {\nreturn Boolean(node._lightChildren !== undefined);\n},\n_parentNeedsDistribution: function (parent) {\nreturn parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);\n},\n_removeNodeFromParent: function (node) {\nvar parent = node._lightParent || node.parentNode;\nif (parent && hasDomApi(parent)) {\nfactory(parent).notifyObserver();\n}\nthis._removeNodeFromHost(node, true);\n},\n_removeNodeFromHost: function (node, ensureComposedRemoval) {\nvar hostNeedsDist;\nvar root;\nvar parent = node._lightParent;\nif (parent) {\nfactory(node)._distributeParent();\nroot = this._ownerShadyRootForNode(node);\nif (root) {\nroot.host._elementRemove(node);\nhostNeedsDist = this._removeDistributedChildren(root, node);\n}\nthis._removeLogicalInfo(node, parent);\n}\nthis._removeOwnerShadyRoot(node);\nif (root && hostNeedsDist) {\nthis._updateInsertionPoints(root.host);\nthis._lazyDistribute(root.host);\n} else if (ensureComposedRemoval) {\nremoveFromComposedParent(getComposedParent(node), node);\n}\n},\n_removeDistributedChildren: function (root, container) {\nvar hostNeedsDist;\nvar ip$ = root._insertionPoints;\nfor (var i = 0; i < ip$.length; i++) {\nvar content = ip$[i];\nif (this._contains(container, content)) {\nvar dc$ = factory(content).getDistributedNodes();\nfor (var j = 0; j < dc$.length; j++) {\nhostNeedsDist = true;\nvar node = dc$[j];\nvar parent = node.parentNode;\nif (parent) {\nremoveFromComposedParent(parent, node);\nnativeRemoveChild.call(parent, node);\n}\n}\n}\n}\nreturn hostNeedsDist;\n},\n_contains: function (container, node) {\nwhile (node) {\nif (node == container) {\nreturn true;\n}\nnode = factory(node).parentNode;\n}\n},\n_addNodeToHost: function (node) {\nvar root = this.getOwnerRoot();\nif (root) {\nroot.host._elementAdd(node);\n}\n},\n_addLogicalInfo: function (node, container, index) {\nvar children = factory(container).childNodes;\nindex = index === undefined ? children.length : index;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nvar c$ = Array.prototype.slice.call(node.childNodes);\nfor (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\nchildren.splice(index++, 0, n);\nn._lightParent = container;\n}\n} else {\nchildren.splice(index, 0, node);\nnode._lightParent = container;\n}\n},\n_removeLogicalInfo: function (node, container) {\nvar children = factory(container).childNodes;\nvar index = children.indexOf(node);\nif (index < 0 || container !== node._lightParent) {\nthrow Error('The node to be removed is not a child of this node');\n}\nchildren.splice(index, 1);\nnode._lightParent = null;\n},\n_removeOwnerShadyRoot: function (node) {\nif (this._hasCachedOwnerRoot(node)) {\nvar c$ = factory(node).childNodes;\nfor (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {\nthis._removeOwnerShadyRoot(n);\n}\n}\nnode._ownerShadyRoot = undefined;\n},\n_firstComposedNode: function (content) {\nvar n$ = factory(content).getDistributedNodes();\nfor (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {\np$ = factory(n).getDestinationInsertionPoints();\nif (p$[p$.length - 1] === content) {\nreturn n;\n}\n}\n},\nquerySelector: function (selector) {\nreturn this.querySelectorAll(selector)[0];\n},\nquerySelectorAll: function (selector) {\nreturn this._query(function (n) {\nreturn matchesSelector.call(n, selector);\n}, this.node);\n},\n_query: function (matcher, node) {\nnode = node || this.node;\nvar list = [];\nthis._queryElements(factory(node).childNodes, matcher, list);\nreturn list;\n},\n_queryElements: function (elements, matcher, list) {\nfor (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {\nif (c.nodeType === Node.ELEMENT_NODE) {\nthis._queryElement(c, matcher, list);\n}\n}\n},\n_queryElement: function (node, matcher, list) {\nif (matcher(node)) {\nlist.push(node);\n}\nthis._queryElements(factory(node).childNodes, matcher, list);\n},\ngetDestinationInsertionPoints: function () {\nreturn this.node._destinationInsertionPoints || [];\n},\ngetDistributedNodes: function () {\nreturn this.node._distributedNodes || [];\n},\nqueryDistributedElements: function (selector) {\nvar c$ = this.getEffectiveChildNodes();\nvar list = [];\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.nodeType === Node.ELEMENT_NODE && matchesSelector.call(c, selector)) {\nlist.push(c);\n}\n}\nreturn list;\n},\ngetEffectiveChildNodes: function () {\nvar list = [];\nvar c$ = this.childNodes;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.localName === CONTENT) {\nvar d$ = factory(c).getDistributedNodes();\nfor (var j = 0; j < d$.length; j++) {\nlist.push(d$[j]);\n}\n} else {\nlist.push(c);\n}\n}\nreturn list;\n},\n_clear: function () {\nwhile (this.childNodes.length) {\nthis.removeChild(this.childNodes[0]);\n}\n},\nsetAttribute: function (name, value) {\nthis.node.setAttribute(name, value);\nthis._distributeParent();\n},\nremoveAttribute: function (name) {\nthis.node.removeAttribute(name);\nthis._distributeParent();\n},\n_distributeParent: function () {\nif (this._parentNeedsDistribution(this.parentNode)) {\nthis._lazyDistribute(this.parentNode);\n}\n},\ncloneNode: function (deep) {\nvar n = nativeCloneNode.call(this.node, false);\nif (deep) {\nvar c$ = this.childNodes;\nvar d = factory(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = factory(c$[i]).cloneNode(true);\nd.appendChild(nc);\n}\n}\nreturn n;\n},\nimportNode: function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nvar n = nativeImportNode.call(doc, externalNode, false);\nif (deep) {\nvar c$ = factory(externalNode).childNodes;\nvar d = factory(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = factory(doc).importNode(c$[i], true);\nd.appendChild(nc);\n}\n}\nreturn n;\n},\nobserveNodes: function (callback) {\nif (callback) {\nif (!this.observer) {\nthis.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);\n}\nreturn this.observer.addListener(callback);\n}\n},\nunobserveNodes: function (handle) {\nif (this.observer) {\nthis.observer.removeListener(handle);\n}\n},\nnotifyObserver: function () {\nif (this.observer) {\nthis.observer.notify();\n}\n}\n};\nif (!Settings.useShadow) {\nObject.defineProperties(DomApi.prototype, {\nchildNodes: {\nget: function () {\nvar c$ = getLightChildren(this.node);\nreturn Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nreturn Array.prototype.filter.call(this.childNodes, function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n},\nconfigurable: true\n},\nparentNode: {\nget: function () {\nreturn this.node._lightParent || getComposedParent(this.node);\n},\nconfigurable: true\n},\nfirstChild: {\nget: function () {\nreturn this.childNodes[0];\n},\nconfigurable: true\n},\nlastChild: {\nget: function () {\nvar c$ = this.childNodes;\nreturn c$[c$.length - 1];\n},\nconfigurable: true\n},\nnextSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).childNodes;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) + 1];\n}\n},\nconfigurable: true\n},\npreviousSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).childNodes;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) - 1];\n}\n},\nconfigurable: true\n},\nfirstElementChild: {\nget: function () {\nreturn this.children[0];\n},\nconfigurable: true\n},\nlastElementChild: {\nget: function () {\nvar c$ = this.children;\nreturn c$[c$.length - 1];\n},\nconfigurable: true\n},\nnextElementSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).children;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) + 1];\n}\n},\nconfigurable: true\n},\npreviousElementSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).children;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) - 1];\n}\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn this.node.textContent;\n} else {\nvar tc = [];\nfor (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {\nif (c.nodeType !== Node.COMMENT_NODE) {\ntc.push(c.textContent);\n}\n}\nreturn tc.join('');\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nthis.node.textContent = text;\n} else {\nthis._clear();\nif (text) {\nthis.appendChild(document.createTextNode(text));\n}\n}\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn null;\n} else {\nreturn getInnerHTML(this.node);\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {\nthis._clear();\nvar d = document.createElement('div');\nd.innerHTML = text;\nvar c$ = Array.prototype.slice.call(d.childNodes);\nfor (var i = 0; i < c$.length; i++) {\nthis.appendChild(c$[i]);\n}\n}\n},\nconfigurable: true\n}\n});\nDomApi.prototype._getComposedInnerHTML = function () {\nreturn getInnerHTML(this.node, true);\n};\n} else {\nvar forwardMethods = [\n'cloneNode',\n'appendChild',\n'insertBefore',\n'removeChild',\n'replaceChild'\n];\nforwardMethods.forEach(function (name) {\nDomApi.prototype[name] = function () {\nreturn this.node[name].apply(this.node, arguments);\n};\n});\nDomApi.prototype.querySelectorAll = function (selector) {\nreturn Array.prototype.slice.call(this.node.querySelectorAll(selector));\n};\nDomApi.prototype.getOwnerRoot = function () {\nvar n = this.node;\nwhile (n) {\nif (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {\nreturn n;\n}\nn = n.parentNode;\n}\n};\nDomApi.prototype.importNode = function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nreturn doc.importNode(externalNode, deep);\n};\nDomApi.prototype.getDestinationInsertionPoints = function () {\nvar n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();\nreturn n$ ? Array.prototype.slice.call(n$) : [];\n};\nDomApi.prototype.getDistributedNodes = function () {\nvar n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();\nreturn n$ ? Array.prototype.slice.call(n$) : [];\n};\nDomApi.prototype._distributeParent = function () {\n};\nvar nativeForwards = [\n'appendChild',\n'insertBefore',\n'removeChild',\n'replaceChild'\n];\nnativeForwards.forEach(function (forward) {\nDomApi.prototype[forward] = function () {\nreturn this.node[forward].apply(this.node, arguments);\n};\n});\nObject.defineProperties(DomApi.prototype, {\nchildNodes: {\nget: function () {\nreturn Array.prototype.slice.call(this.node.childNodes);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nreturn Array.prototype.slice.call(this.node.children);\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nreturn this.node.textContent;\n},\nset: function (value) {\nreturn this.node.textContent = value;\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nreturn this.node.innerHTML;\n},\nset: function (value) {\nreturn this.node.innerHTML = value;\n},\nconfigurable: true\n}\n});\nvar forwardProperties = [\n'parentNode',\n'firstChild',\n'lastChild',\n'nextSibling',\n'previousSibling',\n'firstElementChild',\n'lastElementChild',\n'nextElementSibling',\n'previousElementSibling'\n];\nforwardProperties.forEach(function (name) {\nObject.defineProperty(DomApi.prototype, name, {\nget: function () {\nreturn this.node[name];\n},\nconfigurable: true\n});\n});\n}\nvar CONTENT = 'content';\nfunction factory(node, patch) {\nnode = node || document;\nif (!node.__domApi) {\nnode.__domApi = new DomApi(node, patch);\n}\nreturn node.__domApi;\n}\n;\nfunction hasDomApi(node) {\nreturn Boolean(node.__domApi);\n}\nPolymer.dom = function (obj, patch) {\nif (obj instanceof Event) {\nreturn Polymer.EventApi.factory(obj);\n} else {\nreturn factory(obj, patch);\n}\n};\nfunction getLightChildren(node) {\nvar children = node._lightChildren;\nreturn children ? children : node.childNodes;\n}\nfunction getComposedChildren(node) {\nif (!node._composedChildren) {\nnode._composedChildren = Array.prototype.slice.call(node.childNodes);\n}\nreturn node._composedChildren;\n}\nfunction addToComposedParent(parent, node, ref_node) {\nvar children = getComposedChildren(parent);\nvar i = ref_node ? children.indexOf(ref_node) : -1;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nvar fragChildren = getComposedChildren(node);\nfor (var j = 0; j < fragChildren.length; j++) {\naddNodeToComposedChildren(fragChildren[j], parent, children, i + j);\n}\nnode._composedChildren = null;\n} else {\naddNodeToComposedChildren(node, parent, children, i);\n}\n}\nfunction getComposedParent(node) {\nreturn node.__patched ? node._composedParent : node.parentNode;\n}\nfunction addNodeToComposedChildren(node, parent, children, i) {\nnode._composedParent = parent;\nchildren.splice(i >= 0 ? i : children.length, 0, node);\n}\nfunction removeFromComposedParent(parent, node) {\nnode._composedParent = null;\nif (parent) {\nvar children = getComposedChildren(parent);\nvar i = children.indexOf(node);\nif (i >= 0) {\nchildren.splice(i, 1);\n}\n}\n}\nfunction saveLightChildrenIfNeeded(node) {\nif (!node._lightChildren) {\nvar c$ = Array.prototype.slice.call(node.childNodes);\nfor (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\nchild._lightParent = child._lightParent || node;\n}\nnode._lightChildren = c$;\n}\n}\nfunction hasInsertionPoint(root) {\nreturn Boolean(root && root._insertionPoints.length);\n}\nvar p = Element.prototype;\nvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\nreturn {\ngetLightChildren: getLightChildren,\ngetComposedParent: getComposedParent,\ngetComposedChildren: getComposedChildren,\nremoveFromComposedParent: removeFromComposedParent,\nsaveLightChildrenIfNeeded: saveLightChildrenIfNeeded,\nmatchesSelector: matchesSelector,\nhasInsertionPoint: hasInsertionPoint,\nctor: DomApi,\nfactory: factory,\nhasDomApi: hasDomApi\n};\n}();\nPolymer.Base.extend(Polymer.dom, {\n_flushGuard: 0,\n_FLUSH_MAX: 100,\n_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,\n_debouncers: [],\n_staticFlushList: [],\n_finishDebouncer: null,\nflush: function () {\nthis._flushGuard = 0;\nthis._prepareFlush();\nwhile (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {\nfor (var i = 0; i < this._debouncers.length; i++) {\nthis._debouncers[i].complete();\n}\nif (this._finishDebouncer) {\nthis._finishDebouncer.complete();\n}\nthis._prepareFlush();\nthis._flushGuard++;\n}\nif (this._flushGuard >= this._FLUSH_MAX) {\nconsole.warn('Polymer.dom.flush aborted. Flush may not be complete.');\n}\n},\n_prepareFlush: function () {\nif (this._needsTakeRecords) {\nCustomElements.takeRecords();\n}\nfor (var i = 0; i < this._staticFlushList.length; i++) {\nthis._staticFlushList[i]();\n}\n},\naddStaticFlush: function (fn) {\nthis._staticFlushList.push(fn);\n},\nremoveStaticFlush: function (fn) {\nvar i = this._staticFlushList.indexOf(fn);\nif (i >= 0) {\nthis._staticFlushList.splice(i, 1);\n}\n},\naddDebouncer: function (debouncer) {\nthis._debouncers.push(debouncer);\nthis._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);\n},\n_finishFlush: function () {\nPolymer.dom._debouncers = [];\n}\n});\nPolymer.EventApi = function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nDomApi.Event = function (event) {\nthis.event = event;\n};\nif (Settings.useShadow) {\nDomApi.Event.prototype = {\nget rootTarget() {\nreturn this.event.path[0];\n},\nget localTarget() {\nreturn this.event.target;\n},\nget path() {\nreturn this.event.path;\n}\n};\n} else {\nDomApi.Event.prototype = {\nget rootTarget() {\nreturn this.event.target;\n},\nget localTarget() {\nvar current = this.event.currentTarget;\nvar currentRoot = current && Polymer.dom(current).getOwnerRoot();\nvar p$ = this.path;\nfor (var i = 0; i < p$.length; i++) {\nif (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {\nreturn p$[i];\n}\n}\n},\nget path() {\nif (!this.event._path) {\nvar path = [];\nvar o = this.rootTarget;\nwhile (o) {\npath.push(o);\no = Polymer.dom(o).parentNode || o.host;\n}\npath.push(window);\nthis.event._path = path;\n}\nreturn this.event._path;\n}\n};\n}\nvar factory = function (event) {\nif (!event.__eventApi) {\nevent.__eventApi = new DomApi.Event(event);\n}\nreturn event.__eventApi;\n};\nreturn { factory: factory };\n}();\n(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nObject.defineProperty(DomApi.prototype, 'classList', {\nget: function () {\nif (!this._classList) {\nthis._classList = new DomApi.ClassList(this);\n}\nreturn this._classList;\n},\nconfigurable: true\n});\nDomApi.ClassList = function (host) {\nthis.domApi = host;\nthis.node = host.node;\n};\nDomApi.ClassList.prototype = {\nadd: function () {\nthis.node.classList.add.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\nremove: function () {\nthis.node.classList.remove.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\ntoggle: function () {\nthis.node.classList.toggle.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\ncontains: function () {\nreturn this.node.classList.contains.apply(this.node.classList, arguments);\n}\n};\n}());\n(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nvar hasDomApi = Polymer.DomApi.hasDomApi;\nDomApi.EffectiveNodesObserver = function (domApi) {\nthis.domApi = domApi;\nthis.node = this.domApi.node;\nthis._listeners = [];\n};\nDomApi.EffectiveNodesObserver.prototype = {\naddListener: function (callback) {\nif (!this._isSetup) {\nthis._setup();\nthis._isSetup = true;\n}\nvar listener = {\nfn: callback,\n_nodes: []\n};\nthis._listeners.push(listener);\nthis._scheduleNotify();\nreturn listener;\n},\nremoveListener: function (handle) {\nvar i = this._listeners.indexOf(handle);\nif (i >= 0) {\nthis._listeners.splice(i, 1);\nhandle._nodes = [];\n}\nif (!this._hasListeners()) {\nthis._cleanup();\nthis._isSetup = false;\n}\n},\n_setup: function () {\nthis._observeContentElements(this.domApi.childNodes);\n},\n_cleanup: function () {\nthis._unobserveContentElements(this.domApi.childNodes);\n},\n_hasListeners: function () {\nreturn Boolean(this._listeners.length);\n},\n_scheduleNotify: function () {\nif (this._debouncer) {\nthis._debouncer.stop();\n}\nthis._debouncer = Polymer.Debounce(this._debouncer, this._notify);\nthis._debouncer.context = this;\nPolymer.dom.addDebouncer(this._debouncer);\n},\nnotify: function () {\nif (this._hasListeners()) {\nthis._scheduleNotify();\n}\n},\n_notify: function (mxns) {\nthis._beforeCallListeners();\nthis._callListeners();\n},\n_beforeCallListeners: function () {\nthis._updateContentElements();\n},\n_updateContentElements: function () {\nthis._observeContentElements(this.domApi.childNodes);\n},\n_observeContentElements: function (elements) {\nfor (var i = 0, n; i < elements.length && (n = elements[i]); i++) {\nif (this._isContent(n)) {\nn.__observeNodesMap = n.__observeNodesMap || new WeakMap();\nif (!n.__observeNodesMap.has(this)) {\nn.__observeNodesMap.set(this, this._observeContent(n));\n}\n}\n}\n},\n_observeContent: function (content) {\nvar h = Polymer.dom(content).observeNodes(this._scheduleNotify.bind(this));\nh._avoidChangeCalculation = true;\nreturn h;\n},\n_unobserveContentElements: function (elements) {\nfor (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {\nif (this._isContent(n)) {\nh = n.__observeNodesMap.get(this);\nif (h) {\nPolymer.dom(n).unobserveNodes(h);\nn.__observeNodesMap.delete(this);\n}\n}\n}\n},\n_isContent: function (node) {\nreturn node.localName === 'content';\n},\n_callListeners: function () {\nvar o$ = this._listeners;\nvar nodes = this._getEffectiveNodes();\nfor (var i = 0, o; i < o$.length && (o = o$[i]); i++) {\nvar info = this._generateListenerInfo(o, nodes);\nif (info || o._alwaysNotify) {\nthis._callListener(o, info);\n}\n}\n},\n_getEffectiveNodes: function () {\nreturn this.domApi.getEffectiveChildNodes();\n},\n_generateListenerInfo: function (listener, newNodes) {\nif (listener._avoidChangeCalculation) {\nreturn true;\n}\nvar oldNodes = listener._nodes;\nvar info = {\ntarget: this.node,\naddedNodes: [],\nremovedNodes: []\n};\nvar splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\ninfo.removedNodes.push(n);\n}\n}\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = s.index; j < s.index + s.addedCount; j++) {\ninfo.addedNodes.push(newNodes[j]);\n}\n}\nlistener._nodes = newNodes;\nif (info.addedNodes.length || info.removedNodes.length) {\nreturn info;\n}\n},\n_callListener: function (listener, info) {\nreturn listener.fn.call(this.node, info);\n},\nenableShadowAttributeTracking: function () {\n}\n};\nif (Settings.useShadow) {\nvar baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;\nvar baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;\nvar beforeCallListeners = DomApi.EffectiveNodesObserver.prototype._beforeCallListeners;\nPolymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {\n_setup: function () {\nif (!this._observer) {\nvar self = this;\nthis._mutationHandler = function (mxns) {\nif (mxns && mxns.length) {\nself._scheduleNotify();\n}\n};\nthis._observer = new MutationObserver(this._mutationHandler);\nthis._boundFlush = this._flush.bind(this);\nPolymer.dom.addStaticFlush(this._boundFlush);\nthis._observer.observe(this.node, { childList: true });\n}\nbaseSetup.call(this);\n},\n_cleanup: function () {\nthis._observer.disconnect();\nthis._observer = null;\nthis._mutationHandler = null;\nPolymer.dom.removeStaticFlush(this._boundFlush);\nbaseCleanup.call(this);\n},\n_flush: function () {\nif (this._observer) {\nthis._mutationHandler(this._observer.takeRecords());\n}\n},\nenableShadowAttributeTracking: function () {\nif (this._observer) {\nthis._makeContentListenersAlwaysNotify();\nthis._observer.disconnect();\nthis._observer.observe(this.node, {\nchildList: true,\nattributes: true,\nsubtree: true\n});\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host && Polymer.dom(host).observer) {\nPolymer.dom(host).observer.enableShadowAttributeTracking();\n}\n}\n},\n_makeContentListenersAlwaysNotify: function () {\nfor (var i = 0, h; i < this._listeners.length; i++) {\nh = this._listeners[i];\nh._alwaysNotify = h._isContentListener;\n}\n}\n});\n}\n}());\n(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nDomApi.DistributedNodesObserver = function (domApi) {\nDomApi.EffectiveNodesObserver.call(this, domApi);\n};\nDomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);\nPolymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {\n_setup: function () {\n},\n_cleanup: function () {\n},\n_beforeCallListeners: function () {\n},\n_getEffectiveNodes: function () {\nreturn this.domApi.getDistributedNodes();\n}\n});\nif (Settings.useShadow) {\nPolymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {\n_setup: function () {\nif (!this._observer) {\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host) {\nthis._observer = Polymer.dom(host).observeNodes(this._scheduleNotify.bind(this));\nthis._observer._isContentListener = true;\nif (this._hasAttrSelect()) {\nPolymer.dom(host).observer.enableShadowAttributeTracking();\n}\n}\n}\n},\n_hasAttrSelect: function () {\nvar select = this.node.getAttribute('select');\nreturn select && select.match(/[[.]+/);\n},\n_cleanup: function () {\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host) {\nPolymer.dom(host).unobserveNodes(this._observer);\n}\nthis._observer = null;\n}\n});\n}\n}());\n(function () {\nvar hasDomApi = Polymer.DomApi.hasDomApi;\nPolymer.Base._addFeature({\n_prepShady: function () {\nthis._useContent = this._useContent || Boolean(this._template);\n},\n_poolContent: function () {\nif (this._useContent) {\nsaveLightChildrenIfNeeded(this);\n}\n},\n_setupRoot: function () {\nif (this._useContent) {\nthis._createLocalRoot();\nif (!this.dataHost) {\nupgradeLightChildren(this._lightChildren);\n}\n}\n},\n_createLocalRoot: function () {\nthis.shadyRoot = this.root;\nthis.shadyRoot._distributionClean = false;\nthis.shadyRoot._isShadyRoot = true;\nthis.shadyRoot._dirtyRoots = [];\nvar i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];\nsaveLightChildrenIfNeeded(this.shadyRoot);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nsaveLightChildrenIfNeeded(c);\nsaveLightChildrenIfNeeded(c.parentNode);\n}\nthis.shadyRoot.host = this;\n},\nget domHost() {\nvar root = Polymer.dom(this).getOwnerRoot();\nreturn root && root.host;\n},\ndistributeContent: function (updateInsertionPoints) {\nif (this.shadyRoot) {\nvar dom = Polymer.dom(this);\nif (updateInsertionPoints) {\ndom._updateInsertionPoints(this);\n}\nvar host = getTopDistributingHost(this);\ndom._lazyDistribute(host);\n}\n},\n_distributeContent: function () {\nif (this._useContent && !this.shadyRoot._distributionClean) {\nthis._beginDistribute();\nthis._distributeDirtyRoots();\nthis._finishDistribute();\n}\n},\n_beginDistribute: function () {\nif (this._useContent && hasInsertionPoint(this.shadyRoot)) {\nthis._resetDistribution();\nthis._distributePool(this.shadyRoot, this._collectPool());\n}\n},\n_distributeDirtyRoots: function () {\nvar c$ = this.shadyRoot._dirtyRoots;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._distributeContent();\n}\nthis.shadyRoot._dirtyRoots = [];\n},\n_finishDistribute: function () {\nif (this._useContent) {\nthis.shadyRoot._distributionClean = true;\nif (hasInsertionPoint(this.shadyRoot)) {\nthis._composeTree();\nnotifyContentObservers(this.shadyRoot);\n} else {\nif (!this.shadyRoot._hasDistributed) {\nthis.textContent = '';\nthis._composedChildren = null;\nthis.appendChild(this.shadyRoot);\n} else {\nvar children = this._composeNode(this);\nthis._updateChildNodes(this, children);\n}\n}\nif (!this.shadyRoot._hasDistributed) {\nnotifyInitialDistribution(this);\n}\nthis.shadyRoot._hasDistributed = true;\n}\n},\nelementMatches: function (selector, node) {\nnode = node || this;\nreturn matchesSelector.call(node, selector);\n},\n_resetDistribution: function () {\nvar children = getLightChildren(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (child._destinationInsertionPoints) {\nchild._destinationInsertionPoints = undefined;\n}\nif (isInsertionPoint(child)) {\nclearDistributedDestinationInsertionPoints(child);\n}\n}\nvar root = this.shadyRoot;\nvar p$ = root._insertionPoints;\nfor (var j = 0; j < p$.length; j++) {\np$[j]._distributedNodes = [];\n}\n},\n_collectPool: function () {\nvar pool = [];\nvar children = getLightChildren(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (isInsertionPoint(child)) {\npool.push.apply(pool, child._distributedNodes);\n} else {\npool.push(child);\n}\n}\nreturn pool;\n},\n_distributePool: function (node, pool) {\nvar p$ = node._insertionPoints;\nfor (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\nthis._distributeInsertionPoint(p, pool);\nmaybeRedistributeParent(p, this);\n}\n},\n_distributeInsertionPoint: function (content, pool) {\nvar anyDistributed = false;\nfor (var i = 0, l = pool.length, node; i < l; i++) {\nnode = pool[i];\nif (!node) {\ncontinue;\n}\nif (this._matchesContentSelect(node, content)) {\ndistributeNodeInto(node, content);\npool[i] = undefined;\nanyDistributed = true;\n}\n}\nif (!anyDistributed) {\nvar children = getLightChildren(content);\nfor (var j = 0; j < children.length; j++) {\ndistributeNodeInto(children[j], content);\n}\n}\n},\n_composeTree: function () {\nthis._updateChildNodes(this, this._composeNode(this));\nvar p$ = this.shadyRoot._insertionPoints;\nfor (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {\nparent = p._lightParent || p.parentNode;\nif (!parent._useContent && parent !== this && parent !== this.shadyRoot) {\nthis._updateChildNodes(parent, this._composeNode(parent));\n}\n}\n},\n_composeNode: function (node) {\nvar children = [];\nvar c$ = getLightChildren(node.shadyRoot || node);\nfor (var i = 0; i < c$.length; i++) {\nvar child = c$[i];\nif (isInsertionPoint(child)) {\nvar distributedNodes = child._distributedNodes;\nfor (var j = 0; j < distributedNodes.length; j++) {\nvar distributedNode = distributedNodes[j];\nif (isFinalDestination(child, distributedNode)) {\nchildren.push(distributedNode);\n}\n}\n} else {\nchildren.push(child);\n}\n}\nreturn children;\n},\n_updateChildNodes: function (container, children) {\nvar composed = getComposedChildren(container);\nvar splices = Polymer.ArraySplice.calculateSplices(children, composed);\nfor (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\nif (getComposedParent(n) === container) {\nremove(n);\n}\ncomposed.splice(s.index + d, 1);\n}\nd -= s.addedCount;\n}\nfor (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {\nnext = composed[s.index];\nfor (var j = s.index, n; j < s.index + s.addedCount; j++) {\nn = children[j];\ninsertBefore(container, n, next);\ncomposed.splice(j, 0, n);\n}\n}\nensureComposedParent(container, children);\n},\n_matchesContentSelect: function (node, contentElement) {\nvar select = contentElement.getAttribute('select');\nif (!select) {\nreturn true;\n}\nselect = select.trim();\nif (!select) {\nreturn true;\n}\nif (!(node instanceof Element)) {\nreturn false;\n}\nvar validSelectors = /^(:not\\()?[*.#[a-zA-Z_|]/;\nif (!validSelectors.test(select)) {\nreturn false;\n}\nreturn this.elementMatches(select, node);\n},\n_elementAdd: function () {\n},\n_elementRemove: function () {\n}\n});\nvar saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;\nvar getLightChildren = Polymer.DomApi.getLightChildren;\nvar matchesSelector = Polymer.DomApi.matchesSelector;\nvar hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;\nvar getComposedChildren = Polymer.DomApi.getComposedChildren;\nvar getComposedParent = Polymer.DomApi.getComposedParent;\nvar removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;\nfunction distributeNodeInto(child, insertionPoint) {\ninsertionPoint._distributedNodes.push(child);\nvar points = child._destinationInsertionPoints;\nif (!points) {\nchild._destinationInsertionPoints = [insertionPoint];\n} else {\npoints.push(insertionPoint);\n}\n}\nfunction clearDistributedDestinationInsertionPoints(content) {\nvar e$ = content._distributedNodes;\nif (e$) {\nfor (var i = 0; i < e$.length; i++) {\nvar d = e$[i]._destinationInsertionPoints;\nif (d) {\nd.splice(d.indexOf(content) + 1, d.length);\n}\n}\n}\n}\nfunction maybeRedistributeParent(content, host) {\nvar parent = content._lightParent;\nif (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {\nparent.shadyRoot._distributionClean = false;\nhost.shadyRoot._dirtyRoots.push(parent);\n}\n}\nfunction isFinalDestination(insertionPoint, node) {\nvar points = node._destinationInsertionPoints;\nreturn points && points[points.length - 1] === insertionPoint;\n}\nfunction isInsertionPoint(node) {\nreturn node.localName == 'content';\n}\nvar nativeInsertBefore = Element.prototype.insertBefore;\nvar nativeRemoveChild = Element.prototype.removeChild;\nfunction insertBefore(parentNode, newChild, refChild) {\nvar newChildParent = getComposedParent(newChild);\nif (newChildParent !== parentNode) {\nremoveFromComposedParent(newChildParent, newChild);\n}\nremove(newChild);\nnativeInsertBefore.call(parentNode, newChild, refChild || null);\nnewChild._composedParent = parentNode;\n}\nfunction remove(node) {\nvar parentNode = getComposedParent(node);\nif (parentNode) {\nnode._composedParent = null;\nnativeRemoveChild.call(parentNode, node);\n}\n}\nfunction ensureComposedParent(parent, children) {\nfor (var i = 0, n; i < children.length; i++) {\nchildren[i]._composedParent = parent;\n}\n}\nfunction getTopDistributingHost(host) {\nwhile (host && hostNeedsRedistribution(host)) {\nhost = host.domHost;\n}\nreturn host;\n}\nfunction hostNeedsRedistribution(host) {\nvar c$ = Polymer.dom(host).children;\nfor (var i = 0, c; i < c$.length; i++) {\nc = c$[i];\nif (c.localName === 'content') {\nreturn host.domHost;\n}\n}\n}\nfunction notifyContentObservers(root) {\nfor (var i = 0, c; i < root._insertionPoints.length; i++) {\nc = root._insertionPoints[i];\nif (hasDomApi(c)) {\nPolymer.dom(c).notifyObserver();\n}\n}\n}\nfunction notifyInitialDistribution(host) {\nif (hasDomApi(host)) {\nPolymer.dom(host).notifyObserver();\n}\n}\nvar needsUpgrade = window.CustomElements && !CustomElements.useNative;\nfunction upgradeLightChildren(children) {\nif (needsUpgrade && children) {\nfor (var i = 0; i < children.length; i++) {\nCustomElements.upgrade(children[i]);\n}\n}\n}\n}());\nif (Polymer.Settings.useShadow) {\nPolymer.Base._addFeature({\n_poolContent: function () {\n},\n_beginDistribute: function () {\n},\ndistributeContent: function () {\n},\n_distributeContent: function () {\n},\n_finishDistribute: function () {\n},\n_createLocalRoot: function () {\nthis.createShadowRoot();\nthis.shadowRoot.appendChild(this.root);\nthis.root = this.shadowRoot;\n}\n});\n}\nPolymer.DomModule = document.createElement('dom-module');\nPolymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepAttributes();\nthis._prepBehaviors();\nthis._prepConstructor();\nthis._prepTemplate();\nthis._prepShady();\n},\n_prepBehavior: function (b) {\nthis._addHostAttributes(b.hostAttributes);\n},\n_initFeatures: function () {\nthis._poolContent();\nthis._pushHost();\nthis._stampTemplate();\nthis._popHost();\nthis._marshalHostAttributes();\nthis._setupDebouncers();\nthis._marshalBehaviors();\nthis._tryReady();\n},\n_marshalBehavior: function (b) {\n}\n});</script>\n\n"],"file":"polymer/polymer-mini.html","sourceRoot":"/source/"}